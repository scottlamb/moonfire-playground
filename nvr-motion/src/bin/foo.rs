extern crate moonfire_ffmpeg;
extern crate moonfire_motion;

//use cstr::*;
use std::env;
use std::ffi::CString;

fn main() {
    let url = env::args().nth(1).expect("missing url");
    let _ffmpeg = moonfire_ffmpeg::Ffmpeg::new();
    let mut open_options = moonfire_ffmpeg::Dictionary::new();
    let mut input = moonfire_ffmpeg::InputFormatContext::open(&CString::new(url).unwrap(),
                                                              &mut open_options).unwrap();
    println!("open");
    input.find_stream_info().unwrap();

    // In .mp4 files generated by Moonfire NVR, the video is always stream 0.
    // The timestamp subtitles (if any) are stream 1.
    const VIDEO_STREAM: usize = 0;

    let s = input.streams().get(VIDEO_STREAM);
    let par = s.codecpar();
    let mut dopt = moonfire_ffmpeg::Dictionary::new();
    //dopt.set(cstr!("refcounted_frames"), cstr!("0")).unwrap();  // TODO?
    let d = par.new_decoder(&mut dopt).unwrap();
    //println!("pixel format: {}", d.pix_fmt());

    // TODO: get proper dimensions and pix_fmt from TensorFlow model.
    let mut scaled = moonfire_ffmpeg::VideoFrame::owned(moonfire_ffmpeg::ImageDimensions {
        width: 300,
        height: 300,
        pix_fmt: par.dims().pix_fmt,
    }).unwrap();
    let mut f = moonfire_ffmpeg::VideoFrame::empty().unwrap();
    let mut s = moonfire_ffmpeg::Scaler::new(par.dims(), scaled.dims()).unwrap();
    let mut frame_num = 0;
    loop {
        let pkt = match input.read_frame() {
            Ok(p) => p,
            Err(e) if e.is_eof() => { break; },
            Err(e) => panic!(e),
        };
        if pkt.stream_index() != VIDEO_STREAM {
            continue;
        }
        if !d.decode_video(&pkt, &mut f).unwrap() {
            continue;
        }
        frame_num += 1;
        println!("frame {}", frame_num);
        s.scale(&f, &mut scaled);
    }
}

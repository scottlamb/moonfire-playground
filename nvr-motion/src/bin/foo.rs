extern crate moonfire_ffmpeg;
extern crate moonfire_motion;

use moonfire_motion::{Processor, MotionProcessor};

//use cstr::*;
use std::env;
use std::ffi::CString;

fn main() {
    let url = env::args().nth(1).expect("missing url");
    let _ffmpeg = moonfire_ffmpeg::Ffmpeg::new();
    let mut open_options = moonfire_ffmpeg::Dictionary::new();
    let mut input = moonfire_ffmpeg::InputFormatContext::open(&CString::new(url).unwrap(),
                                                              &mut open_options).unwrap();
    println!("open");
    input.find_stream_info().unwrap();

    // In .mp4 files generated by Moonfire NVR, the video is always stream 0.
    // The timestamp subtitles (if any) are stream 1.
    const VIDEO_STREAM: usize = 0;

    let s = input.streams().get(VIDEO_STREAM);
    let cp = s.codecpar();
    let mut dopt = moonfire_ffmpeg::Dictionary::new();
    //dopt.set(cstr!("refcounted_frames"), cstr!("0")).unwrap();  // TODO?
    let d = cp.new_decoder(&mut dopt).unwrap();
    //println!("pixel format: {}", d.pix_fmt());
    //let img = moonfire_ffmpeg::Image::new(c.width(), c.height(), c.pix_fmt(), 1).unwrap();
    let mut f = moonfire_ffmpeg::Frame::new().unwrap();
    let mut p: Option<MotionProcessor> = None;
    loop {
        let pkt = match input.read_frame() {
            Ok(p) => p,
            Err(e) if e.is_eof() => { break; },
            Err(e) => panic!(e),
        };
        println!("packet, stream {}", pkt.stream_index());
        if pkt.stream_index() != VIDEO_STREAM {
            continue;
        }
        if !d.decode_video(&pkt, &mut f).unwrap() {
            continue;
        }
        println!("frame");
        p = Some(match p {
            None => MotionProcessor::new(&f),
            Some(mut p) => { p.process(&f).unwrap(); p },
        });
    }
}
